#!/usr/bin/env python

# Generate lightcone for DESI mocks
# from HOD catalogues generated by Shadab

import sys
import glob
import configparser
from itertools import product
import multiprocessing as mp

import numpy as np
from astropy.table import Table
import desimodel.footprint as foot
import desimodel.io
import h5py


def bits(ask="try"):
	"Used"
	if ask == "LC":              return 0 #(0 0 0 0)
	if ask == "downsample":      return 1 #(0 0 0 1)
	if ask == "Y5foot":          return 2 #(0 0 1 0)
	if ask == "SV3foot":         return 4 #(0 1 0 0)
	if ask == "downsample_main": return 8 #(1 0 0 0)
	sys.exit()

def mask(main=0, nz=0, Y5=0, sv3=0):
	return nz * (2**0) + Y5 * (2**1) + sv3 * (2**2) + main * (2**3)

def get_nz(zz, config, ask=None):
	''' The function where the n(z) is read
	and the NZ column is computed for the given
	redshifts.
	'''

	z, nz = np.loadtxt(config["nz"][ask], usecols=(config["nz"]["col_z"], config["nz"]["col_z"]), unpack=True)

	z_n = z
	nz_n = (nz / ( 1 - config.getfloat('failurerate', ask) )) * 1.0

	np.savetxt(config["nz"][ask + "_red_cor"], np.array([z_n, nz_n]).T)

	return np.interp(zz, z_n, nz_n, left=0, right=0)


def downsample_aux(z_cosmo, ran, n_mean, config, ask=None):
	""" downsample galaxies following n(z) model specified in galtype"""

	nz = get_nz(z_cosmo, config, ask=ask)

	# downsample
	nz_selected = ran < nz / n_mean
	idx         = np.where(nz_selected)
	print("DOWNSAMPLE: Selected {} out of {} galaxies.".format(len(idx[0]), len(z_cosmo)), flush=True)

	bitval = bits(ask=ask)

	newbits = np.zeros(len(z_cosmo), dtype=np.int32)
	newbits[idx] = bitval

	return newbits


def downsample(galtype, n_mean, z_cosmo, config):
	""" downsample galaxies following n(z) model specified in galtype"""

	ran     = np.random.rand(len(z_cosmo))

	newbits = downsample_aux(z_cosmo, ran, n_mean, config, ask="downsample")

	if galtype == "LRG":
		newbits_main = downsample_aux(z_cosmo, ran, n_mean, config, ask="downsample_main")
		outbits = np.bitwise_or(newbits, newbits_main)

		return outbits, ran

	return newbits, ran


def apply_footprint(ra, dec, footprint_mask):
	""" apply desi footprint """

	bitval = 0
	# footprint_mask possibilities
	# 0 - Y5 DESI, 2 - SV3 DESI

	if footprint_mask == 0:
		tiles = desimodel.io.load_tiles()
		point = foot.is_point_in_desi(tiles, ra, dec)
		bitval = bits(ask="Y5foot")
	elif footprint_mask == 2:
		tiles = Table.read('/global/cfs/cdirs/desi/survey/ops/surveyops/trunk/ops/tiles-sv3.ecsv')
		point = foot.is_point_in_desi(tiles, ra, dec)
		bitval = bits(ask="SV3foot")
	else:
		print("ERROR: Wrong footprint.")
		sys.exit()

	idx   = np.where(point)

	print("FOOTPRINT: Selected {} out of {} galaxies.".format(len(idx[0]), len(ra)), flush=True)

	newbits = np.zeros(len(ra), dtype=np.int32)
	newbits[idx] = bitval

	return newbits


def generate_shell(args):
	file_, galtype, tracer_id, footprint_mask, todo, config = args
	print(f"INFO: Read {file_}")

	f = h5py.File(file_, 'r+')
	n_mean = f.attrs["NGAL"] / (f.attrs["BOX_LENGTH"]**3)

	shellnum = f.attrs["SHELLNUM"]
	cat_seed = f.attrs["CAT_SEED"]

	unique_seed = tracer_id * 500500 + 250 * cat_seed + shellnum
	print("INFO: UNIQUE SEED:", unique_seed, flush=True)
	np.random.seed(unique_seed)

	data = f['galaxy']
	ra = data['RA'][()]
	dec = data['DEC'][()]
	z_cosmo = data['Z_COSMO'][()]

	foot_bit0 = apply_footprint(ra, dec, 0)
	foot_bit2 = apply_footprint(ra, dec, 2)
	foot_bit = np.bitwise_or(foot_bit0, foot_bit2)

	down_bit, ran_arr = downsample(galtype, n_mean, z_cosmo, config)

	out_arr = np.bitwise_or(foot_bit, down_bit)
	out_arr = out_arr.astype(np.int32)

	if "STATUS" in data.keys():
		print("WARNING: STATUS EXISTS. New STATUS has not been written.")
	else:
		f.create_dataset('galaxy/STATUS', data=out_arr,  dtype=np.int32)

	if "RAN_NUM_0_1" in data.keys():
		print("WARNING: RAN_NUM_0_1 EXISTS. New RAN_NUM_0_1 has not been written.")
	else:
		f.create_dataset('galaxy/RAN_NUM_0_1', data=ran_arr, dtype=np.float32)

	f.close()


class SurveyGeometry():
	def __init__(self, config_file, args, galtype=None):
		config     = configparser.ConfigParser()
		config.read(config_file)
		self.config = config

		self.box_length       =  config.getint('sim', 'box_length')
		self.zmin       =  config.getfloat('sim', 'zmin')
		self.zmax       =  config.getfloat('sim', 'zmax')

		self.galtype = galtype

		self.tracer_id = 0

		if galtype in ("LRG", "LRG_main"):
			self.tracer_id = 0
		elif galtype == "ELG":
			self.tracer_id = 1
		elif galtype == "QSO":
			self.tracer_id = 2

		print(f"INFO: {self.galtype} with {self.tracer_id} ID")

	def shell(self, path_instance, nproc=5, footprint_mask=0, todo=1):

		infiles = glob.glob(path_instance.shells_out_path + "/*.h5py")

		args = product(infiles, [self.galtype], [self.tracer_id], [footprint_mask], [todo], [self.config])

		if nproc > len(infiles):
			nproc = len(infiles)

		with mp.Pool(processes=nproc) as pool:
			pool.map_async(generate_shell, args)

			pool.close()
			pool.join()

	def shell_series(self, path_instance, footprint_mask=0, todo=1):

		infiles = glob.glob(path_instance.shells_out_path + "/*.h5py")

		for file_ in infiles:
			args = [file_, self.galtype, self.tracer_id, footprint_mask, todo, self.config]
			generate_shell(args)
