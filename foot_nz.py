#!/usr/bin/env python

# Generate lightcone for DESI mocks
# from HOD catalogues generated by Shadab

import sys
import os
import glob
import tracemalloc
import time
import configparser
import warnings
import pandas as pd
import multiprocessing as mp

from scipy.interpolate import interp1d
import numpy as np
import healpy as hp

from astropy.io import fits
#from desimodel.io import fits
from astropy.table import Table, vstack
import desimodel.footprint as foot
import desimodel.io
import h5py
import fitsio


def bits(ask="try"):
	if ask == "LC": return 0
	if ask == "downsample": return 1
	if ask == "entireDESIfoot": return 2
	if ask == "SV3foot": return 4
	sys.exit()

def combine_shells(path_instance):
	start_time = time.time()
	
	# files = glob.glob(path_instance.begin_out_shell + "_*")
	print(path_instance.begin_out_shell.format("*", "*"))
	files = glob.glob(path_instance.begin_out_shell.format("*", "*") + "*")
		
	print(f"There are {len(files)} files")

	out_file_beg = path_instance.dir_out + path_instance.input_name[:-4]

	tot_ra = np.array([])
	tot_dec = np.array([])
	tot_zz = np.array([])
	tot_zz_rsd = np.array([])
	tot_nz = np.array([])

	shells = []
	for i, file_ in enumerate(files):
		start_time = time.time()
		shells.append(Table.read(file_))
	
	joint_table = vstack(shells)
	joint_table.write(out_file_beg  + path_instance.end_combined_file)
	print("TIME: It took {} seconds to combine all shells.".format(time.time()-start_time))
		
def nz_oneperc(zz, nz_pars):
	if nz_pars['galtype'] == "lrg":
		z, nz = np.loadtxt("./nz_sv3/sm_LRG_mycosmo_v0.1.dat", usecols=(0,1), unpack=True)
		failurerate = 0.01
	elif nz_pars['galtype'] == "elgS":
		z, nz = np.loadtxt("./nz_sv3/sm_ELG_mycosmo_zS0.6_v0.1.dat", usecols=(0,1), unpack=True)
		failurerate = 0.25
	elif nz_pars['galtype'] == "elg":
		z, nz = np.loadtxt("./nz_sv3/sm_ELG_mycosmo_zL0.6_v0.1.dat", usecols=(0,1), unpack=True)
		failurerate = 0.25
	elif nz_pars['galtype'] == "qso":
		z, nz = np.loadtxt("./nz_sv3/sm_QSO.dat", usecols=(0,1), unpack=True)
		failurerate = 0.15
	else:
		raise RuntimeError("Unknown galaxy type.")

	nz = (nz / ( 1 - failurerate )) * 1.0
	# nleft = int((np.min(z)-0.1) / nz_pars['zmin'])
	# zleft = np.linspace(nz_pars['zmin'], np.min(z), nleft + 1)
	# nzleft = np.zeros(nleft + 1)

	# nright = int((nz_pars['zmax'] +0.1)/ np.max(z))
	# zright = np.linspace(np.max(z), nz_pars['zmax']+0.1, nright + 1)
	# nzright = np.zeros(nright + 1)

	# nz_n = np.concatenate((nz, nzright))
	# z_n = np.concatenate((z, zright))

	nz_n = nz
	z_n = z
	print(np.min(zz), np.max(zz))
	print(np.min(z_n), np.max(z_n))
	print(nz_pars['zmin'], nz_pars['zmax'])

	# nzint = interp1d(z_n, nz_n, fill_value=(0,0))

	np.savetxt("./nz_sv3/" + nz_pars['galtype'] + "_sm_nz__mycosmo_redcor_v0.1.txt", np.array([z_n, nz_n]).T)
	# return nzint(zz)
	return np.interp(zz, z_n, nz_n, left=0, right=0)

def downsample(file_, boxL, nz_pars):
	""" downsample galaxies following n(z) model specified in nz_pars """

	print(file_)
	fits = fitsio.FITS(file_,'rw')
	z_cosmo = fits[1].read_column("Z_COSMO")
	hdr = fits[1].read_header()
	n_mean = hdr["NGAL"]/(boxL**3)
	nz         = nz_oneperc(z_cosmo, nz_pars)

	# downsample
	ran         = np.random.rand(len(z_cosmo))
	nz_selected = (ran<nz/n_mean)
	idx         = np.where(nz_selected)

	print("Selected {} out of {} galaxies.".format(len(idx[0]), len(z_cosmo)))

	newbits = np.zeros(len(z_cosmo), dtype=np.int32)
	bitval = bits(ask="downsample")
	newbits[idx] = bitval

	if "STATUS" in fits[1].get_colnames():
		print("STATUS EXISTS")
		status = fits[1].read_column("STATUS")
		out_type=[('STATUS', np.int32)]
		out_arr = np.bitwise_or(status, newbits)
		out_arr = out_arr.astype(out_type)
		print(out_arr.dtype)
		fits[1].write(out_arr)
	else:
		fits[1].insert_column('STATUS', newbits)


def apply_footprint(file_, fullfootprint):
	""" apply desi footprint """
	
	print(file_)
	fits = fitsio.FITS(file_,'rw')
	ra = fits[1].read_column("RA")
	dec = fits[1].read_column("DEC")
	
	newbits = np.zeros(len(ra), dtype=np.int32)
	bitval = 0
	# fullfootprint possibilities
	# 0 - Full DESI, 1 - old 1%, 2 - new 1%

	if fullfootprint == 0:
		tiles = desimodel.io.load_tiles()
		point = foot.is_point_in_desi(tiles, ra, dec)
		bitval = bits(ask="entireDESIfoot")
	elif fullfootprint == 2:
		tiles = Table.read('/global/cfs/cdirs/desi/survey/ops/surveyops/trunk/ops/tiles-sv3.ecsv')
		point = foot.is_point_in_desi(tiles, ra, dec)
		bitval = bits(ask="SV3foot")
	else:
		print("ERROR: Wrong footprint.")
		exit()
	
	idx   = np.where(point)

	newbits[idx] = bitval

	print("Selected {} out of {} galaxies.".format(len(idx[0]), len(ra)))

	if "STATUS" in fits[1].get_colnames():
		print("STATUS EXISTS")
		status = fits[1].read_column("STATUS")
		out_type=[('STATUS', np.int32)]
		out_arr = np.bitwise_or(status, newbits)
		out_arr = out_arr.astype(out_type)
		print(out_arr.dtype)
		fits[1].write(out_arr)
	else:
		fits[1].insert_column('STATUS', newbits)

class FOOT_NZ():
	def __init__(self, config_file, args, galtype = "elg"):
		config     = configparser.ConfigParser()
		config.read(config_file)

		self.boxL       =  config.getint('sim', 'boxL')
		self.zmin       =  config.getfloat('sim', 'zmin')
		self.zmax       =  config.getfloat('sim', 'zmax')
		
		nz_par = dict()

		nz_par["galtype"]       = galtype
		nz_par["zmin"]          = config.getfloat(f'{galtype}', 'zmin', fallback=self.zmin)
		nz_par["zmax"]          = config.getfloat(f'{galtype}', 'zmax', fallback=self.zmax)
		nz_par["galtype_index"] = config.getint(f'{galtype}', 'sample_index')
	
		self.nz_par = nz_par
	
	def shell(self, path_instance, nproc=5, fullfootprint=0, todo=1):
		start = time.time()
		
		infiles = glob.glob(path_instance.shells_out_path + "/*fits")

		counter = 0
		jobs = []
		print(len(infiles))
		for file_ in infiles:
			if todo == 0:
				p = mp.Process(target=apply_footprint, args=(file_, fullfootprint))
			elif todo == 1:
				p = mp.Process(target=downsample, args=(file_, self.boxL, self.nz_par))
	
			jobs.append(p)
			p.start()
			counter = counter + 1
			if (counter == nproc):
				for proc in jobs:
					proc.join()
				counter = 0
				jobs = []
