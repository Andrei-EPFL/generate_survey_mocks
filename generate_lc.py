#!/usr/bin/env python

# Generate lightcone for DESI mocks
# from HOD catalogues generated by Shadab

import sys
import os
import tracemalloc
import time
import configparser
import multiprocessing as mp

import camb
import numpy as np
import healpy as hp
import numexpr as ne
ne.set_num_threads(4)

from astropy.io import fits

import h5py

from rotation_matrix import RotationMatrix
		
def tp2rd(tht, phi):
	""" convert theta,phi to ra/dec """
	ra  = phi / np.pi * 180.0
	dec = -1 * (tht / np.pi * 180.0 - 90.0)
	return ra, dec


class Paths_LC():
	def __init__(self, config_file, args, in_part_path, input_name, shells_path, output_name):
		config     = configparser.ConfigParser()
		config.read(config_file)

		self.dir_out                 = args.dir_out
		self.input_name              = input_name
		self.output_name             = output_name
		self.shells_path 			 = shells_path
		self.dir_gcat                = args.dir_gcat

		if self.dir_out is None:
			self.dir_out       =  config.get('dir', 'dir_out')
		if self.input_name is None:
			self.input_name    =  config.get('dir', 'input_name')
		if self.shells_path is None:
			self.shells_path   =  config.get('dir', 'shells_path')
		if self.dir_gcat is None:
			self.dir_gcat      =  config.get('dir', 'dir_gcat')

		self.dir_gcat = self.dir_gcat + in_part_path	
		self.input_file = self.dir_gcat + self.input_name
		self.shells_out_path = self.create_outpath()
		self.begin_out_shell = self.shells_out_path + self.output_name

	def create_outpath(self):	
		start = time.time()
		out_path = self.dir_out + "/"+ self.shells_path
		print(out_path)
		if not os.path.exists(out_path):
			os.makedirs(out_path)
		print("TIME: It took {} seconds to create the dir.".format(time.time()-start))
		return out_path

class LC():
	def __init__(self, config_file, args):
		config     = configparser.ConfigParser()
		config.read(config_file)

		self.file_camb      =  config.get('dir', 'file_camb')
		self.boxL           =  config.getint('sim', 'boxL')
		self.shellwidth     =  config.getint('sim', 'shellwidth')
		self.zmin       =  config.getfloat('sim', 'zmin')
		self.zmax       =  config.getfloat('sim', 'zmax')
		self.origin  = [0, 0, 0]
		self.clight  = 299792458.

		self.h, self.results = self.run_camb()
		file_alist     =  config.get('dir','file_alist')
		self.alist = np.loadtxt(file_alist)

		rotation_matrix_instance = RotationMatrix(config_file, args)
		self.rotation_matrix = rotation_matrix_instance.rotation_matrix


	def run_camb(self):
		#Load all parameters from camb file 
		start = time.time()
		pars = camb.read_ini(self.file_camb)
		h    = pars.h
		pars.set_for_lmax(2000, lens_potential_accuracy=3)
		pars.set_matter_power(redshifts=[0.], kmax=200.0)
		pars.NonLinearModel.set_params(halofit_version='takahashi')
		camb.set_feedback_level(level=100)
		results   = camb.get_results(pars)
		print("TIME: It took {} seconds to run the CAMB part.".format(time.time()-start))
		return h, results


	def compute_shellnums(self):
		start = time.time()
		shellnum_min = int(self.results.comoving_radial_distance(self.zmin)*self.h // self.shellwidth)
		shellnum_max = int(self.results.comoving_radial_distance(self.zmax)*self.h // self.shellwidth + 1)
		shellnums = list(range(shellnum_min, shellnum_max+1))
		print(f"INFO: There are {len(shellnums)} shells.")
		print("TIME: It took {} seconds to run compute the shellnums.".format(time.time()-start))
		return shellnums


	def checkslicehit(self, chilow, chihigh, xx, yy, zz):
		""" pre-select so that we're not loading non-intersecting blocks """
		boxL = self.boxL
		origin = self.origin
		bvx=np.array([0, boxL, boxL, 0,    0,    boxL, boxL, 0])
		bvy=np.array([0,    0, boxL, boxL, 0,    0,    boxL, boxL])
		bvz=np.array([0,    0,   0,  0,    boxL, boxL, boxL, boxL])

		boo = 0
		r   = np.zeros(8)
		for i in range(0, 8):
			sx  = (bvx[i] - origin[0] + boxL * xx);
			sy  = (bvy[i] - origin[1] + boxL * yy);
			sz  = (bvz[i] - origin[2] + boxL * zz);
			r[i]= np.sqrt(sx * sx + sy * sy + sz * sz)
		if chihigh<np.min(r):
			boo=boo+1
		if chilow>np.max(r):
			boo=boo+1
		if (boo==0):
			return True
		else:
			return False


	def convert_xyz2rdz(self, data, preffix, chilow, chiupp):
		""" Generates and saves a single lightcone shell """		
		clight = self.clight
		boxL = self.boxL
		origin = self.origin

		ntiles = int(np.ceil(chiupp/boxL))
		print(preffix + "tiling [%dx%dx%d]"%(2*ntiles,2*ntiles,2*ntiles))
		print(preffix + 'Generating map for halos in the range [%3.f - %.3f Mpc/h]'%(chilow,chiupp))
		
		px    = data['x']
		py    = data['y']
		pz    =	data['z']
		
		ngalbox=len(px)
		print(preffix + "using %d halos"%len(px))
		
		### For randoms
		id_   = data['id']
		vx = np.zeros(ngalbox)
		vy = np.zeros(ngalbox)
		vz = np.zeros(ngalbox)

		### For DATA		
		# vx    = data['vx']
		# vy    = data['vy']
		# vz    = data['vz']
		
		#-------------------------------------------------------------------

		totra   = np.array([])
		totdec  = np.array([])
		totz    = np.array([])
		totdz   = np.array([])
		# totvlos = np.array([])
		# totpx   = np.array([])
		# totpy   = np.array([])
		# totpz   = np.array([])
		
		### For randoms
		totid   = np.array([])
		

		[axx, axy, axz, ayx, ayy, ayz, azx, azy, azz] = self.rotation_matrix

		for xx in range(-ntiles,ntiles):
			for yy in range(-ntiles,ntiles):
				for zz in range(-ntiles,ntiles):

					# slicehit = self.checkslicehit(chilow,chiupp,xx,yy,zz)             # Check if box intersects with shell
					# slicehit = True
					# if slicehit==True:

					sx_0  = ne.evaluate("px -%d + boxL * xx"%origin[0])
					sy_0  = ne.evaluate("py -%d + boxL * yy"%origin[1])
					sz_0  = ne.evaluate("pz -%d + boxL * zz"%origin[2])
					
					sx = ne.evaluate("axx * sx_0 + axy * sy_0 + axz * sz_0")
					sy = ne.evaluate("ayx * sx_0 + ayy * sy_0 + ayz * sz_0")
					sz = ne.evaluate("azx * sx_0 + azy * sy_0 + azz * sz_0")

					r   = ne.evaluate("sqrt(sx*sx + sy*sy + sz*sz)")
					
					zi  = self.results.redshift_at_comoving_radial_distance(r/self.h) # interpolated distance from position
										
					idx = np.where((r>chilow) & (r<chiupp))[0]              # only select halos that are within the shell

					if idx.size!=0:
						
						ux=sx[idx]/r[idx]
						uy=sy[idx]/r[idx]
						uz=sz[idx]/r[idx]
						
						qx=vx[idx]*1000.
						qy=vy[idx]*1000.
						qz=vz[idx]*1000.
						zp=zi[idx]
						
						### For randoms
						idtmp = id_[idx]
						###

						tht, phi = hp.vec2ang(np.c_[ux, uy, uz])
						ra,dec  = tp2rd(tht,phi)
						
						vlos    = ne.evaluate("qx*ux + qy*uy + qz*uz")
						dz      = ne.evaluate("(vlos/clight)*(1+zp)")

						totra   = np.append(totra,ra)
						totdec  = np.append(totdec,dec)
						totz    = np.append(totz,zp)
						totdz   = np.append(totdz,dz)
						# totvlos = np.append(totvlos,vlos/1000.) # to convert back to km/s
						
						### For randoms
						totid   = np.append(totid, idtmp)
						###

		# return totid, totpx, totpy, totpz, totra, totdec, totz, totz + totdz, ngalbox #, totdz, totvlos
		return totid, totra, totdec, totz, totz + totdz, ngalbox


	def getnearestsnap(self, zmid):
		""" get the closest snapshot """
		# zsnap  = 1/self.alist[:,1]-1.
		zsnap  = 1/self.alist[:, 2] - 1.
		index_ = np.argmin(np.abs(zsnap-zmid))

		return int(self.alist[index_, 0]), self.alist[index_, 3]


	def obtain_data(self, subbox, shellnum, shellnums, snapshot, cutsky, path_instance):
		preffix = f"[shellnum={shellnum}; subbox={subbox}] "

		chilow = self.shellwidth*(shellnum+0)
		chiupp = self.shellwidth*(shellnum+1)
		chimid = 0.5*(chilow+chiupp)
		
		if not cutsky:
			zmid        = self.results.redshift_at_comoving_radial_distance(chimid / self.h)
			nearestsnap, nearestred = self.getnearestsnap(zmid)

			infile = path_instance.input_file.format("z%.3f"%(nearestred), nearestsnap, subbox)
			print(infile)
		else:
			infile = path_instance.input_file.format(snapshot, subbox)

		
		try:
			hdul = fits.open(infile, memmap=False)
			data = hdul[1].data
			hdul.close()
			print(f"Subbox {subbox}: The size of the data is:", len(data["x"]))

		except IOError:
			print(preffix + f"WARNING: Couldn't open {infile}.", file=sys.stderr)
			sys.exit()
		
		# current, peak_ = tracemalloc.get_traced_memory()
		# print(f"Current memory usage is {current / 10**6}MB; Peak was {peak_ / 10**6}MB")

		return data, preffix, chilow, chiupp


	def generate_shell(self, subbox, i, shellnum, shellnums, snapshot, cutsky, path_instance, return_dict):

		### Read Data
		data, preffix, chilow, chiupp = self.obtain_data(subbox, shellnum, shellnums, snapshot, cutsky, path_instance)
		
		### Convert XYZ to RA DEC Z
		id0, ra0, dec0, zz0, zz_rsd0, ngalbox = self.convert_xyz2rdz(data, preffix, chilow, chiupp)
		
		n_mean = ngalbox/(1.* self.boxL**3)
		
		shell_subbox_dict = {"id0":id0, "ra0": ra0, "dec0": dec0, "zz0": zz0, "zz_rsd0": zz_rsd0}
		return_dict[subbox] = shell_subbox_dict

		return_dict["NGAL" + str(subbox)] = ngalbox 


	def generate_shells(self, path_instance, snapshot=999, cutsky=True, nproc=5, Nsubboxes=27):
		jobs = []
		ne.set_num_threads(4)
		manager = mp.Manager()
		
		shellnums = self.compute_shellnums()
		for i, shellnum in enumerate(shellnums):
			out_file_beg = path_instance.begin_out_shell + "_shell_" + str(shellnum)

			chilow = self.shellwidth*(shellnum+0)
			chiupp = self.shellwidth*(shellnum+1)
			chimid = 0.5*(chilow+chiupp)
			
			zlow        = self.results.redshift_at_comoving_radial_distance(chilow / self.h)
			if zlow > self.zmax:
				continue

			if not cutsky:
				print("LightCone")
				zmid        = self.results.redshift_at_comoving_radial_distance(chimid / self.h)
				nearestsnap, nearestred = self.getnearestsnap(zmid)
				snapshot = nearestsnap

			out_file_beg = out_file_beg.format(snapshot, "all")
			# Don't reprocess files already done
			if os.path.isfile(out_file_beg+".h5py"):
				continue
		
			return_dict = manager.dict()
			counter = 0
			for subbox in range(Nsubboxes):
				p = mp.Process(target=self.generate_shell, args=(subbox, i, shellnum, shellnums, snapshot, cutsky, path_instance, return_dict))
				jobs.append(p)
				p.start()
				counter = counter + 1
				if (counter == nproc) or (subbox == Nsubboxes - 1):
					for proc in jobs:
						proc.join()
					counter = 0
					jobs = []

			### Count the number of galaxies per shell			
			N_GAL_SHELL_ALL_SUBBOXES = 0
			for subbox in range(Nsubboxes):
				shell_subbox_dict = return_dict[subbox]
				N_GAL_SHELL_ALL_SUBBOXES += len(shell_subbox_dict["ra0"])
			
			### Declare arrays of size 
			ra0_array = np.zeros(N_GAL_SHELL_ALL_SUBBOXES)
			dec0_array = np.zeros(N_GAL_SHELL_ALL_SUBBOXES)
			zz0_array = np.zeros(N_GAL_SHELL_ALL_SUBBOXES)
			zz_rsd0_array = np.zeros(N_GAL_SHELL_ALL_SUBBOXES)
			counter_NGAL = 0
			
			### For randoms
			id0_array = np.zeros(N_GAL_SHELL_ALL_SUBBOXES)
			###

			index_i = 0
			index_f = 0
			for subbox in range(Nsubboxes):
				counter_NGAL += return_dict["NGAL" + str(subbox)]
				shell_subbox_dict = return_dict[subbox]
			
				index_f = index_i + len(shell_subbox_dict["ra0"])

				ra0_array[index_i: index_f]     = shell_subbox_dict["ra0"]
				dec0_array[index_i: index_f]    = shell_subbox_dict["dec0"]
				zz0_array[index_i: index_f]     = shell_subbox_dict["zz0"]
				zz_rsd0_array[index_i: index_f] = shell_subbox_dict["zz_rsd0"]

				### For randoms
				id0_array[index_i: index_f]     = shell_subbox_dict["id0"]
				###

				index_i = index_f 

			out_file_tmp = out_file_beg + "_tmp.h5py"
			out_file 	 = out_file_beg + ".h5py"

			with h5py.File(out_file_tmp, 'w') as ff:
				ff.create_group('galaxy')
				ff.create_dataset('galaxy/RA',      data=ra0_array,    dtype=np.float32)
				ff.create_dataset('galaxy/DEC',     data=dec0_array,   dtype=np.float32)
				ff.create_dataset('galaxy/Z_RSD', 	  data=zz_rsd0_array, dtype=np.float32)
				ff.create_dataset('galaxy/Z_COSMO', data=zz0_array,     dtype=np.float32)
				ff.create_dataset('galaxy/ID', data=id0_array,     dtype=np.int32)
				ff.attrs['NGAL'] = counter_NGAL

			os.rename(out_file_tmp, out_file)
